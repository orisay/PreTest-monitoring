API 와 데이터 저장을 분리

데이터 저장과 관리 기능만을 모아서 CpuMonitoring.java 제작
CpuMonitoring.java는 스케쥴링 관리와 무슨 역할을 하는지 직관적으로 알기 위해서 Service와 분리
가급적 사람이 피하는 시간대로 스케쥴링 시작

서버 시작 시간부터 1분마다 데이터를 저장하기 위해서
10초에 한번씩 1분간 CPU 사용률을 평균을 구해서 저장
데이터 일관성을 위해서 DecimalFormat 사용하여 0.00으로 일관성 유지
@Retryble을 설정하여 예외 처리에도 재시도를 통한 데이터 수집
메인 API에 부담을 덜 가기 위해서 비동기 처리

1.데이터 저장 과정

1. 10초에 한번씩 6번 동안 모은 데이터를 가지고 CPU 사용률을 평균을 계산하여 분 단위 테이블 저장
2.분 단위 조회한 데이터를 스트림을 이용하여 최대 사용량, 최소 사용량, 평균 사용량 계산 후 저장 시 단위 테이블 저장
3.시 단위 조회한 데이터를 스트림을 이용하여 최대 사용량, 최소 사용량, 평균 사용량 계산 후 저장 일 단위 테이블 저장
-> 분 단위 조회한 데이터를 저장하는 것이 더 정확한 데이터를 저장한다는 것을 알았지만 코드를 작성하면서 실수했습니다. 

2.백업 과정

1. CpuMonitoringManageService에서 소프트 딜리트로 플래그 'Y' 변경
2. 플래그 'Y'으로 변경된 것을 전부 CpuMonitoringBackupService 이동
3. 백업 용 Entity로 변경
4. 백업 테이블에 저장

MariaDB에서도 가능하지만 회사에서 AI나 여러가지 시도를 하시는 것 같아서 확장성을 고려하여 
어플리캐이션 내에서 작업 수행

3.하드 딜리트 과정

딜리트로 데이터베이스 비트리 잦은 변화를 막기 위해서
그리고 CPU 사용률이 높은 시간 대를 피하기 위해서 주말 새벽 시간대 지정
또한 @Retryble를 추가하지 않았습니다.

4.API 조회 과정

1.GET을 사용해도 되지만 모니터링을 해야한다면 보안이 중요하다고 생각하고 추후에 사용자 권한 확인이 필요하다고 생각하여 POST로 작성했습니다.
2. 클라이언트가 보낸 정보를 검사하기 위해서 @Valid 사용 이후 DTO에서 처리
3. 분, 시, 일 단위는 데이터 제공 제한이 걸려있어 그에 따른 플래그 조건을 추가 하려했으나 그 부분을 놓쳤습니다.
3. 분,시 단위는 조회 구간이 정해져서  +1시, +1일를 하기 때문에 클라이언트가 정보를 주어 데이터 전송량을 늘리는 것보다 Service에서 처리했습니다.
-> 단 일 단위는 클라이언트가 종료일을 보내야하기에 종료일 정보를 받아야합니다.
-> 추가로 조회 종료일 +1을 자정으로 데이터 조회가 가능케 했습니다.

